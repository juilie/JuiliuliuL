<html>

<head>
    <meta charset="utf-8">
    <title>The MotherPode</title>
    <style>
        body {
            margin: 0;
        }
    </style>
    <link rel="stylesheet" href="three.css">

</head>

<body>
    <script src="scripts/three.js"></script>
    <script>
        // The three main things! Scene, camera, render
        const scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x03f0fc );
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
        camera.position.set(0, 0, 15);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer(); // {alpha:true} for transparency
        // renderer.setClearColorHex( 0xffffff, 1 ); // assumes black background
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setSize(window.innerWidth/2, window.innerHeight/2, false); //makes it low res!
        document.body.appendChild(renderer.domElement); // This is a <canvas> element apparently?

        // NOTE: for low res, which is not used to my knowledge yet !!
        // If you wish to keep the size of your app but render it at a lower resolution, 
        // you can do so by calling setSize with false as updateStyle (the third argument). 
        // For example, setSize(window.innerWidth/2, window.innerHeight/2, false) 
        // will render your app at half resolution, given that your <canvas> has 100% width and height.

        const geometry = new THREE.BoxGeometry();
        const material = new THREE.MeshBasicMaterial({
            color: 0xff00f7
        });
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);
        //create a blue LineBasicMaterial
        const lineMaterial = new THREE.LineDashedMaterial({
            color: 0xffc7fd
        });
        const points = [];
        points.push(new THREE.Vector3(-2, 0, 0));
        points.push(new THREE.Vector3(0, 2, 0));
        points.push(new THREE.Vector3(2, 0, 0));
        points.push(new THREE.Vector3(0, -2, 0));
        points.push(new THREE.Vector3(-2, 0, 0));


        const pointst = [];
        pointst.push(new THREE.Vector3(0, 0, -2));
        pointst.push(new THREE.Vector3(0, 2, 0));
        pointst.push(new THREE.Vector3(0, 0, 2));
        pointst.push(new THREE.Vector3(0, -2, 0));
        pointst.push(new THREE.Vector3(0, 0, -2));

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
        const linetwoGeometry = new THREE.BufferGeometry().setFromPoints(pointst);
        const linetwo = new THREE.Line(linetwoGeometry, lineMaterial);
        scene.add(linetwo);



        function animate() {
            requestAnimationFrame(animate);
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;

            line.rotation.x += 0.03;
            linetwo.rotation.y += 0.03
            // line.rotation.y += 0.013;

        
            cube
            renderer.render(scene, camera);
        }
        animate();
    </script>
    <body>

</body>

</html>